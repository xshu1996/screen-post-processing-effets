// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

CCEffect %{
  techniques:
  - passes:
    - vert: vs
      frag: fs
      blendState:
        targets:
        - blend: true
      rasterizerState:
        cullMode: none
      properties:
        texture: { value: white }
        alphaThreshold: { value: 0.5 }
        u_rect:
          value:
            - 0.0
            - 0.0
        u_roundR:
          value:
            - 0.0
            - 0.0
            - 0.0
            - 0.0
}%


CCProgram vs %{
  precision highp float;

  #include <cc-global>
  #include <cc-local>

  in vec3 a_position;
  in vec4 a_color;
  out vec4 v_color;

  #if USE_TEXTURE
  in vec2 a_uv0;
  out vec2 v_uv0;
  #endif

  void main () {
    vec4 pos = vec4(a_position, 1);

    #if CC_USE_MODEL
    pos = cc_matViewProj * cc_matWorld * pos;
    #else
    pos = cc_matViewProj * pos;
    #endif

    // #if USE_TEXTURE
    v_uv0 = a_uv0;
    // #endif

    v_color = a_color;

    gl_Position = pos;
  }
}%


CCProgram fs %{
  precision highp float;

  #include <alpha-test>
  #include <texture>
  #include <cc-global>

  in vec4 v_color;

  #if USE_TEXTURE
  in vec2 v_uv0;
  uniform sampler2D texture;
  #endif

  uniform Constant
  {
    vec4 u_roundR;
    vec2 u_rect;
  };

  // ç¬¦å·è·ç¦»å‡½æ•°ï¼ˆsign distancefunctionï¼‰ï¼Œç®€ç§°SDFï¼Œåˆå¯ä»¥ç§°ä¸ºå®šå‘è·ç¦»å‡½æ•°ï¼ˆoriented distance functionï¼‰
  // åœ¨ç©ºé—´ä¸­çš„ä¸€ä¸ªæœ‰é™åŒºåŸŸä¸Šç¡®å®šä¸€ä¸ªç‚¹åˆ°åŒºåŸŸè¾¹ç•Œçš„è·ç¦»å¹¶åŒæ—¶å¯¹è·ç¦»çš„ç¬¦å·è¿›è¡Œå®šä¹‰ï¼šç‚¹åœ¨åŒºåŸŸè¾¹ç•Œå†…éƒ¨ä¸ºæ­£ï¼Œå¤–éƒ¨ä¸ºè´Ÿï¼Œä½äºŽè¾¹ç•Œä¸Šæ—¶ä¸º0

  const float PI = 3.1415926535897932384626433832795;
  //---- utils functions

  float ndot(vec2 a, vec2 b) 
  { 
    return a.x*b.x - a.y*b.y; 
  }

  float dot2(vec2 v)
  {
    return dot(v, v);
  }

  //---- end utils functions

  float sdCircle(vec2 p, float r)
  {
    return length(p) - r;
  }

  // å››è¾¹å›ºå®šå¼§åº¦åœ†è¾¹çŸ©å½¢
  float sdFixRoundBox(vec2 p, vec2 b, float r)
  {
    vec2 q = abs(p) - b + r;
    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r;
  }

  // b.x = width
  // b.y = height
  // r.x = roundness top-right  
  // r.y = roundness boottom-right
  // r.z = roundness top-left
  // r.w = roundness bottom-left
  // å››è¾¹ä¸å›ºå®šåœ†å¼§åœ†è¾¹çŸ©å½¢
  float sdRoundBox (vec2 p, vec2 b, vec4 r) 
  {
    r.xy = (p.x > 0.0) ? r.xy : r.zw;
    r.x = (p.y > 0.0) ? r.x : r.y;
    vec2 q = abs(p) - b + r.x;
    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;
  }

  // çŸ©å½¢
  float sdBox(vec2 p, vec2 b)
  {
    vec2 q = abs(p) - b;
    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0));
  }

  // è±å½¢
  float sdRhombus(vec2 p, vec2 b) 
  {
      p = abs(p);
      float h = clamp(ndot(b - 2.0 * p, b) / dot(b, b), -1.0, 1.0);
      float d = length(p - 0.5 * b * vec2(1.0 - h, 1.0 + h));
      return d * sign(p.x * b.y + p.y * b.x - b.x * b.y);
  }
  // å¿ƒå½¢ðŸ§¡
  float sdHeart(vec2 p)
  {
      p.x = abs(p.x);

      if (p.y + p.x > 1.0)
      {
        return sqrt(dot2(p - vec2(0.25, 0.75))) - sqrt(2.0) / 4.0;
      }
      return sqrt(min(dot2(p - vec2(0.00, 1.00)),
                      dot2(p - 0.5 * max(p.x + p.y, 0.0)))) * sign(p.x - p.y);
  }

  void main () {
    vec4 o = vec4(1, 1, 1, 1);

    #if USE_TEXTURE
      CCTexture(texture, v_uv0, o);
    #endif

    // vec2 iResolution = vec2(400.0, 350.0);
    // vec2 p = (2.0 * v_uv0 * iResolution - iResolution.xy) / iResolution.y;
    vec2 p = 2.0 * v_uv0 - 1.0;
    p.y = 1.0 - p.y;
    float iTime = cc_time.x;
    vec2 si = vec2(0.9, 0.6) + 0.3 * cos(iTime + vec2(0, 2));
    vec4 ra = 0.3 + 0.3 * cos( 2.0 * iTime + vec4(0, 1, 2, 3) );
    ra = min(ra, min(si.x, si.y));

    float d = 0.0;
    // d = sdFixRoundBox(p, si, ra.x);
    // d = sdRoundBox(p, si, ra);
    // d = sdBox(p, si);
    // d = sdRhombus(p, si);

    // ---- å¿ƒè·³æ¨¡æ‹Ÿ
    // å¿ƒçŽ‡
    float heratRate = 89.0 / 60.0;
    // è·³åŠ¨å¹…åº¦
    float danceRange = 0.2;
    float t = cc_time.x * PI;
    d = sdHeart(p + vec2(0.0, -0.5)) + danceRange * fract(0.5 * sin(heratRate * t) + 0.5);
    if (d > 0.0) discard;
    // ---- å¿ƒè·³æ¨¡æ‹Ÿç»“æŸ

    vec3 col = (d > 0.0) ? vec3(0.9, 0.6, 0.3) : vec3(0.65,0.85,1.0);
    col *= 1.0 - exp(-6.0 * abs(d));
    col *= 0.8 + 0.2 * cos(150.0 * d);
    col = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d)));

    o = vec4(col, 1.0);
    o *= v_color;

    ALPHA_TEST(o);

    #if USE_BGRA
      gl_FragColor = o.bgra;
    #else
      gl_FragColor = o.rgba;
    #endif
  }
}%
